using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using BlackoutGuard.Models;

namespace BlackoutGuard.Services
{
    /// <summary>
    /// Service responsible for managing security vulnerabilities
    /// </summary>
    public class VulnerabilityService
    {
        private readonly DataService _dataService;
        private readonly LogService _logService;
        private readonly AlertService _alertService;

        public VulnerabilityService(DataService dataService, LogService logService, AlertService alertService)
        {
            _dataService = dataService ?? throw new ArgumentNullException(nameof(dataService));
            _logService = logService ?? throw new ArgumentNullException(nameof(logService));
            _alertService = alertService ?? throw new ArgumentNullException(nameof(alertService));
        }

        /// <summary>
        /// Creates a new vulnerability
        /// </summary>
        public async Task<Vulnerability> CreateVulnerabilityAsync(string name, string description, 
                                                                VulnerabilitySeverity severity,
                                                                VulnerabilityType type, string affectedSystem, 
                                                                string discoveredBy)
        {
            try
            {
                // Validate inputs
                if (string.IsNullOrWhiteSpace(name))
                    throw new ArgumentException("Vulnerability name cannot be empty", nameof(name));
                
                if (string.IsNullOrWhiteSpace(description))
                    throw new ArgumentException("Vulnerability description cannot be empty", nameof(description));
                
                if (string.IsNullOrWhiteSpace(affectedSystem))
                    throw new ArgumentException("Affected system cannot be empty", nameof(affectedSystem));
                
                if (string.IsNullOrWhiteSpace(discoveredBy))
                    throw new ArgumentException("Discoverer cannot be empty", nameof(discoveredBy));
                
                // Create the vulnerability
                var vulnerability = new Vulnerability(name, description, severity, type, affectedSystem, discoveredBy);
                
                // Generate remediation steps based on type and severity
                vulnerability.RemediationSteps = GenerateRemediationSteps(vulnerability);
                
                // Save the vulnerability
                await _dataService.SaveVulnerabilityAsync(vulnerability);
                _logService.LogSecurity($"New vulnerability created: {name} with severity {severity}");
                
                // Generate an alert for the vulnerability
                await _alertService.CreateVulnerabilityAlertAsync(vulnerability);
                
                return vulnerability;
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error creating vulnerability: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Gets all vulnerabilities
        /// </summary>
        public async Task<List<Vulnerability>> GetAllVulnerabilitiesAsync()
        {
            try
            {
                return await _dataService.GetAllVulnerabilitiesAsync();
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error getting all vulnerabilities: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Gets a vulnerability by ID
        /// </summary>
        public async Task<Vulnerability?> GetVulnerabilityByIdAsync(Guid id)
        {
            try
            {
                return await _dataService.GetVulnerabilityByIdAsync(id);
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error getting vulnerability by ID: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Gets open vulnerabilities
        /// </summary>
        public async Task<List<Vulnerability>> GetOpenVulnerabilitiesAsync()
        {
            try
            {
                var vulnerabilities = await _dataService.GetAllVulnerabilitiesAsync();
                return vulnerabilities.Where(v => v.Status == VulnerabilityStatus.Open || 
                                               v.Status == VulnerabilityStatus.InProgress).ToList();
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error getting open vulnerabilities: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Gets high severity vulnerabilities
        /// </summary>
        public async Task<List<Vulnerability>> GetHighSeverityVulnerabilitiesAsync()
        {
            try
            {
                var vulnerabilities = await _dataService.GetAllVulnerabilitiesAsync();
                return vulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.High || 
                                               v.Severity == VulnerabilitySeverity.Critical).ToList();
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error getting high severity vulnerabilities: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Gets vulnerabilities by type
        /// </summary>
        public async Task<List<Vulnerability>> GetVulnerabilitiesByTypeAsync(VulnerabilityType type)
        {
            try
            {
                var vulnerabilities = await _dataService.GetAllVulnerabilitiesAsync();
                return vulnerabilities.Where(v => v.Type == type).ToList();
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error getting vulnerabilities by type: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Gets vulnerabilities by affected system
        /// </summary>
        public async Task<List<Vulnerability>> GetVulnerabilitiesByAffectedSystemAsync(string affectedSystem)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(affectedSystem))
                    throw new ArgumentException("Affected system cannot be empty", nameof(affectedSystem));
                
                var vulnerabilities = await _dataService.GetAllVulnerabilitiesAsync();
                return vulnerabilities.Where(v => v.AffectedSystem.Contains(affectedSystem, StringComparison.OrdinalIgnoreCase)).ToList();
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error getting vulnerabilities by affected system: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Adds an action to a vulnerability
        /// </summary>
        public async Task AddVulnerabilityActionAsync(Guid id, string description, string performedBy)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(description))
                    throw new ArgumentException("Action description cannot be empty", nameof(description));
                
                if (string.IsNullOrWhiteSpace(performedBy))
                    throw new ArgumentException("Performer cannot be empty", nameof(performedBy));
                
                var vulnerability = await _dataService.GetVulnerabilityByIdAsync(id);
                if (vulnerability == null)
                {
                    throw new InvalidOperationException($"Vulnerability with ID {id} not found");
                }
                
                vulnerability.AddAction(description, performedBy);
                await _dataService.UpdateVulnerabilityAsync(vulnerability);
                
                _logService.LogInfo($"Action added to vulnerability {vulnerability.Name}: {description} by {performedBy}");
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error adding vulnerability action: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Updates a vulnerability's status
        /// </summary>
        public async Task UpdateVulnerabilityStatusAsync(Guid id, VulnerabilityStatus newStatus, string performedBy)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(performedBy))
                    throw new ArgumentException("Performer cannot be empty", nameof(performedBy));
                
                var vulnerability = await _dataService.GetVulnerabilityByIdAsync(id);
                if (vulnerability == null)
                {
                    throw new InvalidOperationException($"Vulnerability with ID {id} not found");
                }
                
                var oldStatus = vulnerability.Status;
                vulnerability.Status = newStatus;
                
                // Add an action for the status change
                vulnerability.AddAction($"Status changed from {oldStatus} to {newStatus}", performedBy);
                
                await _dataService.UpdateVulnerabilityAsync(vulnerability);
                
                _logService.LogInfo($"Vulnerability {vulnerability.Name} status updated from {oldStatus} to {newStatus} by {performedBy}");
                
                // Create an alert for status change if it's an important change
                if (vulnerability.Severity >= VulnerabilitySeverity.High && 
                    (newStatus == VulnerabilityStatus.Patched || newStatus == VulnerabilityStatus.Mitigated))
                {
                    var priority = vulnerability.Severity == VulnerabilitySeverity.Critical ? AlertPriority.High : AlertPriority.Medium;
                    await _alertService.CreateRelatedAlertAsync(
                        $"Vulnerability Status Update: {vulnerability.Name}",
                        $"The status of vulnerability '{vulnerability.Name}' has been changed from {oldStatus} to {newStatus} by {performedBy}.",
                        priority,
                        AlertType.SystemStatus,
                        vulnerability.Id,
                        "Vulnerability"
                    );
                }
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error updating vulnerability status: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Marks a vulnerability as patched
        /// </summary>
        public async Task PatchVulnerabilityAsync(Guid id, string patchedBy, string remediationDetails)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(patchedBy))
                    throw new ArgumentException("Patcher cannot be empty", nameof(patchedBy));
                
                if (string.IsNullOrWhiteSpace(remediationDetails))
                    throw new ArgumentException("Remediation details cannot be empty", nameof(remediationDetails));
                
                var vulnerability = await _dataService.GetVulnerabilityByIdAsync(id);
                if (vulnerability == null)
                {
                    throw new InvalidOperationException($"Vulnerability with ID {id} not found");
                }
                
                vulnerability.MarkAsPatched(patchedBy, remediationDetails);
                await _dataService.UpdateVulnerabilityAsync(vulnerability);
                
                _logService.LogInfo($"Vulnerability {vulnerability.Name} patched by {patchedBy}");
                
                // Create an alert for the patch
                var priority = vulnerability.Severity >= VulnerabilitySeverity.High ? AlertPriority.Medium : AlertPriority.Low;
                await _alertService.CreateRelatedAlertAsync(
                    $"Vulnerability Patched: {vulnerability.Name}",
                    $"The vulnerability '{vulnerability.Name}' has been patched by {patchedBy}.\nRemediation: {remediationDetails}",
                    priority,
                    AlertType.SystemStatus,
                    vulnerability.Id,
                    "Vulnerability"
                );
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error patching vulnerability: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Updates CVSS score for a vulnerability
        /// </summary>
        public async Task UpdateCvssScoreAsync(Guid id, double cvssScore, string cveId, string performedBy)
        {
            try
            {
                if (cvssScore < 0 || cvssScore > 10)
                    throw new ArgumentException("CVSS score must be between 0 and 10", nameof(cvssScore));
                
                if (string.IsNullOrWhiteSpace(performedBy))
                    throw new ArgumentException("Performer cannot be empty", nameof(performedBy));
                
                var vulnerability = await _dataService.GetVulnerabilityByIdAsync(id);
                if (vulnerability == null)
                {
                    throw new InvalidOperationException($"Vulnerability with ID {id} not found");
                }
                
                vulnerability.CvssScore = cvssScore;
                
                if (!string.IsNullOrWhiteSpace(cveId))
                {
                    vulnerability.CveId = cveId;
                }
                
                vulnerability.AddAction($"Updated CVSS score to {cvssScore}" + 
                                       (!string.IsNullOrWhiteSpace(cveId) ? $" and assigned CVE ID {cveId}" : ""), 
                                       performedBy);
                
                await _dataService.UpdateVulnerabilityAsync(vulnerability);
                
                _logService.LogInfo($"Vulnerability {vulnerability.Name} CVSS score updated to {cvssScore} by {performedBy}");
                
                // If high CVSS score, generate alert
                if (cvssScore >= 7.0)
                {
                    var priority = cvssScore >= 9.0 ? AlertPriority.Critical : AlertPriority.High;
                    await _alertService.CreateRelatedAlertAsync(
                        $"High CVSS Score: {vulnerability.Name}",
                        $"The vulnerability '{vulnerability.Name}' has been assigned a high CVSS score of {cvssScore}." +
                        (!string.IsNullOrWhiteSpace(cveId) ? $"\nCVE ID: {cveId}" : ""),
                        priority,
                        AlertType.VulnerabilityFound,
                        vulnerability.Id,
                        "Vulnerability"
                    );
                }
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error updating CVSS score: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Updates a vulnerability
        /// </summary>
        public async Task UpdateVulnerabilityAsync(Vulnerability vulnerability)
        {
            try
            {
                if (vulnerability == null)
                    throw new ArgumentNullException(nameof(vulnerability));
                
                await _dataService.UpdateVulnerabilityAsync(vulnerability);
                _logService.LogInfo($"Vulnerability updated: {vulnerability.Name}");
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error updating vulnerability: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Deletes a vulnerability
        /// </summary>
        public async Task DeleteVulnerabilityAsync(Guid id)
        {
            try
            {
                await _dataService.DeleteVulnerabilityAsync(id);
                _logService.LogInfo($"Vulnerability deleted with ID: {id}");
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error deleting vulnerability: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Performs a vulnerability scan on a system
        /// </summary>
        public async Task<List<Vulnerability>> PerformVulnerabilityScanAsync(string system, string performedBy)
        {
            try
            {
                // In a real system, this would integrate with vulnerability scanning tools
                // For this demo, we'll simulate finding vulnerabilities
                
                _logService.LogInfo($"Starting vulnerability scan on {system} by {performedBy}");
                
                // Simulate scan duration
                await Task.Delay(2000);
                
                // Sample vulnerability types to potentially find
                var vulnerabilityTypes = new[]
                {
                    VulnerabilityType.Authentication,
                    VulnerabilityType.Authorization,
                    VulnerabilityType.Configuration,
                    VulnerabilityType.Firmware,
                    VulnerabilityType.InputValidation,
                    VulnerabilityType.NetworkSecurity,
                    VulnerabilityType.Software
                };
                
                // Simulate finding 0-3 vulnerabilities
                var random = new Random();
                var foundVulnerabilities = new List<Vulnerability>();
                
                var vulnerabilityCount = random.Next(0, 4);
                for (int i = 0; i < vulnerabilityCount; i++)
                {
                    var type = vulnerabilityTypes[random.Next(vulnerabilityTypes.Length)];
                    var severity = (VulnerabilitySeverity)random.Next(0, 4);
                    
                    var vulnerability = await CreateVulnerabilityAsync(
                        $"{type} vulnerability in {system}",
                        $"A {severity.ToString().ToLower()} severity {type.ToString().ToLower()} vulnerability was found during automated scanning.",
                        severity,
                        type,
                        system,
                        performedBy
                    );
                    
                    foundVulnerabilities.Add(vulnerability);
                }
                
                _logService.LogInfo($"Completed vulnerability scan on {system}. Found {vulnerabilityCount} vulnerabilities.");
                
                // Create a summary alert if vulnerabilities were found
                if (foundVulnerabilities.Count > 0)
                {
                    var highSeverityCount = foundVulnerabilities.Count(v => v.Severity >= VulnerabilitySeverity.High);
                    var priority = highSeverityCount > 0 ? AlertPriority.High : AlertPriority.Medium;
                    
                    await _alertService.CreateAlertAsync(
                        $"Vulnerability Scan Results: {system}",
                        $"Vulnerability scan completed on {system}.\nFound {vulnerabilityCount} vulnerabilities " +
                        $"({highSeverityCount} high severity).\nScan performed by: {performedBy}",
                        priority,
                        AlertType.AuditFinding
                    );
                }
                
                return foundVulnerabilities;
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error performing vulnerability scan: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Generates remediation steps based on vulnerability type and severity
        /// </summary>
        private string GenerateRemediationSteps(Vulnerability vulnerability)
        {
            var remediation = new List<string>();
            
            // Basic recommendations based on severity
            switch (vulnerability.Severity)
            {
                case VulnerabilitySeverity.Critical:
                    remediation.Add("URGENT: Immediate action required.");
                    remediation.Add("Consider taking affected systems offline until patched.");
                    remediation.Add("Implement emergency workarounds until a permanent fix is available.");
                    break;
                    
                case VulnerabilitySeverity.High:
                    remediation.Add("Prioritize patching this vulnerability as soon as possible.");
                    remediation.Add("Implement temporary mitigations if patching is delayed.");
                    remediation.Add("Monitor affected systems for exploitation attempts.");
                    break;
                    
                case VulnerabilitySeverity.Medium:
                    remediation.Add("Schedule patching during the next maintenance window.");
                    remediation.Add("Implement available mitigations.");
                    remediation.Add("Monitor security logs for potential exploitation.");
                    break;
                    
                case VulnerabilitySeverity.Low:
                    remediation.Add("Address during regular maintenance cycles.");
                    remediation.Add("Document the vulnerability for future reference.");
                    break;
            }
            
            // Specific recommendations based on vulnerability type
            switch (vulnerability.Type)
            {
                case VulnerabilityType.Authentication:
                    remediation.Add("Review and strengthen authentication mechanisms.");
                    remediation.Add("Implement multi-factor authentication if not already in place.");
                    remediation.Add("Audit password policies and enforce strong password requirements.");
                    break;
                    
                case VulnerabilityType.Authorization:
                    remediation.Add("Review access control policies and permissions.");
                    remediation.Add("Implement least privilege principle for all accounts.");
                    remediation.Add("Audit user access rights and remove unnecessary privileges.");
                    break;
                    
                case VulnerabilityType.Cryptographic:
                    remediation.Add("Update to current cryptographic standards and algorithms.");
                    remediation.Add("Review key management practices.");
                    remediation.Add("Ensure proper implementation of cryptographic functions.");
                    break;
                    
                case VulnerabilityType.InputValidation:
                    remediation.Add("Implement strict input validation on all user inputs.");
                    remediation.Add("Use parameterized queries for database interactions.");
                    remediation.Add("Sanitize all inputs before processing.");
                    break;
                    
                case VulnerabilityType.Configuration:
                    remediation.Add("Apply security hardening guidelines.");
                    remediation.Add("Remove unnecessary services and features.");
                    remediation.Add("Update default configurations to secure settings.");
                    break;
                    
                case VulnerabilityType.LoggingMonitoring:
                    remediation.Add("Enhance logging to capture security-relevant events.");
                    remediation.Add("Implement real-time monitoring and alerts.");
                    remediation.Add("Ensure logs are protected and regularly reviewed.");
                    break;
                    
                case VulnerabilityType.NetworkSecurity:
                    remediation.Add("Implement network segmentation.");
                    remediation.Add("Review and update firewall rules.");
                    remediation.Add("Conduct regular network scanning and monitoring.");
                    break;
                    
                case VulnerabilityType.PhysicalSecurity:
                    remediation.Add("Enhance physical access controls.");
                    remediation.Add("Implement surveillance and monitoring systems.");
                    remediation.Add("Regularly audit physical security measures.");
                    break;
                    
                case VulnerabilityType.Firmware:
                    remediation.Add("Apply latest firmware updates from the vendor.");
                    remediation.Add("Implement integrity verification for firmware updates.");
                    remediation.Add("Consider hardware replacement if firmware cannot be updated.");
                    break;
                    
                case VulnerabilityType.Software:
                    remediation.Add("Apply software patches and updates.");
                    remediation.Add("Consider application whitelisting.");
                    remediation.Add("Remove or isolate vulnerable software until patched.");
                    break;
                    
                case VulnerabilityType.Hardware:
                    remediation.Add("Contact vendor for hardware fixes or replacements.");
                    remediation.Add("Implement compensating controls to mitigate risk.");
                    remediation.Add("Consider hardware replacement if fixes are not available.");
                    break;
            }
            
            return string.Join("\n", remediation);
        }
    }
}
