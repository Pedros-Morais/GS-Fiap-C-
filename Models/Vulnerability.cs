using System;
using System.Collections.Generic;

namespace BlackoutGuard.Models
{
    /// <summary>
    /// Represents a security vulnerability detected in the power grid system
    /// </summary>
    public class Vulnerability
    {
        // Unique identifier for the vulnerability
        public Guid Id { get; private set; }
        
        // Name/title of the vulnerability
        public string Name { get; set; }
        
        // Detailed description of the vulnerability
        public string Description { get; set; }
        
        // When the vulnerability was discovered
        public DateTime DiscoveredAt { get; private set; }
        
        // Current status of the vulnerability
        public VulnerabilityStatus Status { get; set; }
        
        // Severity level of the vulnerability
        public VulnerabilitySeverity Severity { get; set; }
        
        // Type/category of the vulnerability
        public VulnerabilityType Type { get; set; }
        
        // Affected system or component
        public string AffectedSystem { get; set; }
        
        // CVE identifier if applicable (Common Vulnerabilities and Exposures)
        public string CveId { get; set; }
        
        // CVSS score if applicable (Common Vulnerability Scoring System)
        public double? CvssScore { get; set; }
        
        // Recommended steps to address the vulnerability
        public string RemediationSteps { get; set; }
        
        // User who discovered or reported the vulnerability
        public string DiscoveredBy { get; set; }
        
        // User who fixed/patched the vulnerability (if applicable)
        public string PatchedBy { get; set; }
        
        // When the vulnerability was patched (if applicable)
        public DateTime? PatchedAt { get; set; }
        
        // List of actions taken to address the vulnerability
        public List<VulnerabilityAction> Actions { get; set; }

        // Default constructor for deserialization
        public Vulnerability()
        {
            Id = Guid.NewGuid();
            DiscoveredAt = DateTime.UtcNow;
            Status = VulnerabilityStatus.Open;
            Actions = new List<VulnerabilityAction>();
        }

        // Constructor with required fields
        public Vulnerability(string name, string description, VulnerabilitySeverity severity, 
                            VulnerabilityType type, string affectedSystem, string discoveredBy)
        {
            Id = Guid.NewGuid();
            Name = name ?? throw new ArgumentNullException(nameof(name));
            Description = description ?? throw new ArgumentNullException(nameof(description));
            DiscoveredAt = DateTime.UtcNow;
            Status = VulnerabilityStatus.Open;
            Severity = severity;
            Type = type;
            AffectedSystem = affectedSystem ?? throw new ArgumentNullException(nameof(affectedSystem));
            DiscoveredBy = discoveredBy ?? throw new ArgumentNullException(nameof(discoveredBy));
            Actions = new List<VulnerabilityAction>();
        }

        /// <summary>
        /// Adds a new action taken to address the vulnerability
        /// </summary>
        public void AddAction(string description, string performedBy)
        {
            if (string.IsNullOrWhiteSpace(description))
                throw new ArgumentException("Action description cannot be empty", nameof(description));
            
            if (string.IsNullOrWhiteSpace(performedBy))
                throw new ArgumentException("Action performer cannot be empty", nameof(performedBy));
                
            Actions.Add(new VulnerabilityAction
            {
                Description = description,
                PerformedBy = performedBy,
                PerformedAt = DateTime.UtcNow
            });
        }

        /// <summary>
        /// Marks the vulnerability as patched
        /// </summary>
        public void MarkAsPatched(string patchedBy, string remediationDetails)
        {
            if (string.IsNullOrWhiteSpace(patchedBy))
                throw new ArgumentException("Patcher cannot be empty", nameof(patchedBy));
                
            Status = VulnerabilityStatus.Patched;
            PatchedBy = patchedBy;
            PatchedAt = DateTime.UtcNow;
            
            // Add the remediation details to the existing steps
            if (!string.IsNullOrWhiteSpace(remediationDetails))
            {
                RemediationSteps = string.IsNullOrWhiteSpace(RemediationSteps) 
                    ? remediationDetails 
                    : $"{RemediationSteps}\n\nApplied fix: {remediationDetails}";
            }
            
            AddAction($"Vulnerability patched: {remediationDetails}", patchedBy);
        }
    }

    /// <summary>
    /// Represents an action taken to address a vulnerability
    /// </summary>
    public class VulnerabilityAction
    {
        // Description of the action taken
        public string Description { get; set; }
        
        // User who performed the action
        public string PerformedBy { get; set; }
        
        // When the action was performed
        public DateTime PerformedAt { get; set; }
    }

    /// <summary>
    /// Represents the current status of a vulnerability
    /// </summary>
    public enum VulnerabilityStatus
    {
        Open,       // Newly discovered, not yet addressed
        InProgress, // Currently being addressed
        Mitigated,  // Temporarily mitigated but not fully fixed
        Patched,    // Permanently fixed
        Accepted,   // Risk accepted, no fix planned
        Invalid     // Determined to be a false positive
    }

    /// <summary>
    /// Represents the severity level of a vulnerability
    /// </summary>
    public enum VulnerabilitySeverity
    {
        Low,       // Minimal risk
        Medium,    // Moderate risk
        High,      // Significant risk
        Critical   // Severe risk, requires immediate attention
    }

    /// <summary>
    /// Represents the category of a vulnerability
    /// </summary>
    public enum VulnerabilityType
    {
        Authentication,    // Problems with authentication mechanisms
        Authorization,     // Problems with authorization/access control
        Cryptographic,     // Weaknesses in cryptographic implementation
        InputValidation,   // Lack of proper input validation
        Configuration,     // Security misconfigurations
        LoggingMonitoring, // Inadequate logging or monitoring
        NetworkSecurity,   // Network-level vulnerabilities
        PhysicalSecurity,  // Physical access vulnerabilities
        Firmware,          // Vulnerabilities in firmware
        Software,          // Vulnerabilities in software
        Hardware           // Hardware-level vulnerabilities
    }
}
